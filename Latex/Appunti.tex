\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\input{variables.tex}
\input{titlePage.tex}

\preamble

\begin{document}
\customTitlePage{Fondamenti di Ingegneria del Software}{2024-2025}
\newpage
\tableofcontents
\chapter{Modelli di processo di sviluppo software}
\section{Introduzione}
\customfbox{\textbf{Processo}: insieme strutturato e organizzato di attività che si svolgono per ottenere un risultato.}
Perchè modellare il processo? Per dare ordine, controllo e ripetibilità con l'intenzione di migliorare la produttività e la qualità del prodotto.
\subsection{Processo prescrittivo e adattivo}
\begin{itemize}
    \item \textbf{Processo prescrittivo}: un processo che segue un modello predefinito e rigido, con passaggi specifici e ben definiti.
    \item \textbf{Processo adattivo}: un processo che permette modifiche e adattamenti durante il suo svolgimento.
\end{itemize}
Perchè studiare  i modelli di processo? Perchè uno dei compiti dei manager aziendali è quello di decidere il modello di processo da adottare considerando la tipologia del software da progettare e il personale disponibile.
\section{Modelli di processo}
\section{Code and Fix}
\begin{minipage}{0.4\textwidth}
\begin{itemize}
    \item Si arriva al codice finale "per tentativi"
    \item Non adatto per progetti grandi con tanti sviluppatori
    \item \textcolor{red}{Non è un modello di processo vero e proprio}
\end{itemize}
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.5\textwidth}
    \begin{tikzpicture}[node distance=2cm]
        \node (start) [process] {Capire i requisiti};
        \node (process1) [process, below of = start] {Codifica da zero, esecuzione e test};
        \node (dec1) [decision, below of = process1, yshift = -1cm] {Passano i test?};
        \node (process2a) [process, below of = dec1, yshift = -1cm] {Aggiustamento del codice, ri-esecuzione e test};
        \node (stop) [process, left of = dec1, xshift = -2cm] {Consegna del codice};
        \draw [arrow] (start) -- (process1);
        \draw [arrow] (process1) -- (dec1);
        \draw [arrow] (dec1) -- node[anchor=east] {no} (process2a);
        \draw [arrow] (dec1) -- node[anchor=south] {si} (stop);
        \draw [arrow] (process2a.east) -| ++(1,0) |- ([yshift=-0.3cm]process1.south); 
    \end{tikzpicture}
\end{minipage}
\section{Modello a cascata}
\begin{minipage}{0.5\textwidth}
\begin{itemize}
    \item \textcolor{red}{Storicamente il primo modello del processo di sviluppo software}
    \item Ogni fase produce un prodotto che è l'input della fase successiva
    \item Con il modello waterfall abbiamo il passaggio dalla dimensione artigianale alla produzione industriale del software
    \item Molto rigido: non si può tornare indietro
\end{itemize}
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.4\textwidth}
    \includegraphics[width=\linewidth]{Immagini/waterfall.png}
\end{minipage}
\begin{center}

\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
    \hline
    \textbf{\textcolor{green}{Vantaggi}} & \textbf{\textcolor{red}{Svantaggi}} \\
    \hline
    Enfasi su aspetti come l'analisi dei requisiti e il progetto di sistema trascurati nell'approccio code \& fix & Lineare, rigido, monolitico: no feedback tra fasi, no parallelismo, \textcolor{red}{unica data di consegna} \\
    \hline
    Pospone l'implementazione dopo avere capito i bisogni del cliente & La consegna avviene dopo anni, intanto i requisiti cambiano o si chiariscono: così viene consegnato software obsoleto \\
    \hline
    Introduce disciplina e pianificazione & Viene prodotta troppa documentazione poco chiara: l'utente spesso non conosce tutti i requisiti all'inizio dello sviluppo \\
    \hline
    E' applicabile se i requisiti sono chiari e stabili & Alcuni difetti superati da modello waterfall con feedback e iterazioni \\
    \hline
\end{tabular}
\end{center}
\subsection{Studio di fattibilità}
\begin{itemize}
    \item Fase che precede lo sviluppo vero e proprio
    \item Viene analizzata la fattiblità e convenienza del progetto
    \item Stima dei costi
    \item Si valuta il Return Of Investment (ROI)
\end{itemize}
\subsection{Varianti del modello a cascata}
\begin{itemize}
    \item Cascata con prototipazione: prima di iniziare lo sviluppo si costruisce un prototipo "usa e getta" con il solo scopo di fornire agli utenti una base concreta per meglio definire i requisiti.
    \item Cascata con feedback e iterazioni: posso tornare a una fase precedente. \begin{center}
        \includegraphics[width=0.8\linewidth]{Immagini/waterfallfeedback.png}
    \end{center}
    \item V-Model: \begin{itemize}
        \item Enfasi sulle fasi di testing
        \item Evidenzia come le attività di testing (parte destra della V) sono collegate a quelle di analisi e progettazione (parte sinistra della V)
        \item Ogni controllo fatto a destra che non dia buon esito porta a un rifacimento/modifica di quanto fatto a sinistra
        \item \textbf{Parallelismo}: creazione dei test e una volta che ho il codice li eseguo
        \item \textcolor{red}{Problemi (anche per Waterfall)}: \begin{itemize}
            \item Versione funzionante solo alla fine!
            \item Errore in fase iniziale può avere conseguenze disastrose
        \end{itemize}
    \end{itemize}
    \begin{center}
        \includegraphics[width=0.5\linewidth]{Immagini/vmodel.png}
    \end{center}
\end{itemize}
\section{Modelli evolutivi}
\customfbox{Idea: sviluppare un implementazione iniziale, esporla agli utenti e raffinarla attraverso successivi rilasci del SW (release)}
Sottocategorie:
\begin{itemize}
    \item Prototyping
    \item Modelli incrementali
    \item Modelli iterativi
\end{itemize}
\subsection{Modelli a Prototyping}
\begin{itemize}
    \item Realizzazione di un prototipo funzionante del sistema, su cui validare i requisiti (o l'architettura)
    \item Il prototipo ha meno funzionalità ed è meno efficiente
\end{itemize}
\begin{center}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{\textcolor{green}{Vantaggi}} & \textbf{\textcolor{red}{Svantaggi}} \\
        \hline
        Permette di raffinare requisiti definiti in termini di obiettivi generali e troppo vaghi & Il prototipo è un meccanismo per identificare i requisiti, spesso da "buttare": problema economico e psicologico, il rischio è di non farlo e così scelte non ideali diventano parte integrante del sistema \\
        \hline
        Rilevazione precoce di errori di interpretazione & \\
        \hline
    \end{tabular}
\end{center}
\subsection{Modelli Iterativi-Incrementali}
\begin{itemize}
    \item Sviluppo di varie release,  di cui solo l'ultima è completa
    \item Dopo la prima release, si procede in parallelo
    \item Le fasi di sviluppo vengono percorse più volte
\end{itemize}
\begin{center}
    \includegraphics[width=0.5\linewidth]{Immagini/iterativoincrementale.png}
\end{center}
\subsubsection{Modelli Incrementali}
\begin{itemize}
    \item Ogni release aggiunge nuove funzionalità
    \item Nella fase di pianificazione si decide il requisito/funzionalità da includere nella release successiva.
    \item Si trattano per prime le funzionalità ad alto rischio
    \item Si cerca di massimizzare il valore per gli utenti
\end{itemize}
\subsubsection{Modelli Iterativi}
\begin{itemize}
    \item Da subito sono presenti tutte (o buona parte) delle funzionalità che sono via via raffinate, migliorate
\end{itemize}
\section{Modello a spirale}
\begin{itemize}
    \item Sistemi di grandi dimensioni
    \item Approccio "evolutivo" con interazioni continue fra cliente e developer
    \item Modello "risk-driver": tutte le scelte sono basate sui risultati dell'analisi dei rischi
    \item 'Meta-modello': dà un'idea generale ma quando si inizia a lavorare bisogna scegliere un modello esistente \begin{itemize}
        \item Requisiti chiari e stabili $\rightarrow$ modello a cascata
        \item Requisiti confusi $\rightarrow$ prototipo
    \end{itemize}
\end{itemize}
\customfbox{\textbf{Rischio}: circostanza potenzialmente avversa in grado di pregiudicare lo sviluppo e la qualità del software}
\textcolor{red}{Ogni scelta/decisione ha un rischio associato}, due caratteristiche importanti nella valutazione di un rischio sono: \begin{itemize}
    \item Gravità delle conseguenze
    \item Probabilità che si verifichi la circostanza
\end{itemize}
\begin{center}
    \includegraphics[width=0.7\linewidth]{Immagini/spirale.png}
\end{center}
\begin{itemize}
    \item \textbf{Planning}: determinazione di obbiettivi, alternative, vincoli
    \item \textbf{Risk Analysis}: analisi delle alternative e identificazione/risoluzione dei rischi
    \item \textbf{Engineering}: sviluppo del prodotto di successivo livello
    \item \textbf{Customer Evaluation}: valutazione dei risultati dell'engineering dal punto di vista del cliente
\end{itemize}
\begin{center}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{\textcolor{green}{Vantaggi}} & \textbf{\textcolor{red}{Svantaggi}} \\
        \hline
        Adatto allo sviluppo di sistemi complessi & Non è un rimedio universale (panacea) \\
        \hline
        Primo approccio che considera il rischio (risk-driver) & Necessita competenze di alto livello per la stima dei rischi \\
        \hline
        & Richiede  un'opportuna personalizzazione ed esperienza di utilizzo \\
        \hline
        & Se un rischio rilevante non viene scoperto o tenuto a bada si inizia da zero \\
        \hline
    \end{tabular}
\end{center}
\section{Unified Process}
\begin{itemize}
    \item Specifico per sistemi ad oggetti, con uso di notazione UML per tutto il processo
    \item Guidato dagli \textbf{Use Case}
    \item Incorpora molte delle idee 'buone' dal modello a spirale
    \item Meta-modello
    \item Supportato da tool(visuali) in ogni fase
    \item Processo prescrittivo per eccellenza
\end{itemize}
\subsection{Le iterazioni}
\begin{itemize}
    \item Possibili diverse iterazioni che terminano con il rilascio del prodotto
    \item Ogni iterazione consiste di quattro fasi (anche ripetute più volte) che terminano con una milestone (= rilascio di artefatti soggetti a controllo)
    \item Ogni fase è costituita da diverse attività: \begin{itemize}
        \item Requisiti (R)
        \item Analisi (A)
        \item Design (D)
        \item Codifica (C)
        \item Testing (T)
    \end{itemize}
\end{itemize}
\subsection{Le fasi}
\begin{itemize}
    \item Inception: studio di fattibilità, requisiti essenziali del sistema, risk analysis
    \item Elaboration: sviluppa la comprensione del dominio e del problema, gli Use Case della release da rilasciare, l'architettura del sistema
    \item Construction: Design (in UML), codifica e testing del Sistema
    \item Transition: Messa in esercizio della release nel suo ambiente (deploy), training e testing da parte di utenti fidati
\end{itemize}
\section{Sviluppo basato sui componenti}
Modello che va nella direzione del \textbf{riutilizzo del software}
\begin{center}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{\textcolor{green}{Vantaggi}} & \textbf{\textcolor{red}{Svantaggi}} \\
        \hline
        Riduce la quantità di software da scrivere & Sono necessari dei compromessi: requisiti iniziali potrebbero differire da quelli che si possono soddisfare con le componenti disponibili \\
        \hline
        Riduce i costi totali di sviluppo e i rischi & Integrazione non sempre facile \\
        \hline
        Consegne più veloci & Spesso i componenti usati sono fatti evolvere dalla ditta produttrice senza controllo di chi li usa \\
        \hline
    \end{tabular}
\end{center}
\section{Metodi Plan-Driven e Agili}
\begin{center}
    \begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
        \hline
        \textbf{Plan-Driven} & \textbf{Agile} \\
        \hline
        Seguono un approccio classico dell'ingegneria dei sistemi fondato su processi ben definiti e ocn passi standard & Rispondere ai cambiamenti dei requisiti in modo veloce \\
        \hline
        & Filosofia del programmare come "arte" piuttosto che processo industriale \\
        \hline
        & Cosa più importante soddisfare il cliente e non seguire un piano (contratto)\\
        \hline
    \end{tabular}
\end{center}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{Immagini/agilemanifesto.png}
    \caption{The Agile Manifesto}
\end{figure}
\subsection{Come scegliere?}
\textbf{Metodi plan-driven}: \begin{itemize}
    \item Sistemi grandi e comploessi, safety-critical o con forti richieste di affidabilità
    \item Requisiti stabili e ambiente predicibile
\end{itemize}
\textbf{Metodi agili}: \begin{itemize}
    \item Sistemi e team piccoli, clienti e utenti disponibili, ambiente e requisiti volatili
    \item Team con molta esperienza
    \item Tempi di consegna rapidi
\end{itemize}
\newpage
\section{DevOps}
Metodo di sviluppo evolutivo
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{Immagini/devops.png}
    \caption{DevOps}
\end{figure}
\subsection{Continuous Integration}
La Continuos Integration (CI), o Integrazione Continua, è una pratica di sviluppo software in cui i programmatori integrano frequentemente il proprio lavoro (codice) nel repository condiviso del progetto, in genere diverse volte al giorno.
\chapter{Ingegneria dei requisiti}
\section{Introduzione}
Descrivere 'qualcosa' che il sistema dovrà fare (una funzionalità) o un vincolo a cui deve sottostare
\begin{itemize}
    \item \textbf{Diversi livelli di astrazione}:\begin{itemize}
        \item Descrizione astratta ed imprecisa del sistema
        \item Descrizione dettagliata e matematica dello stesso
    \end{itemize}
\end{itemize}
\customfbox{Che cosa il sistema farà e non come!}
E' importante definire i requisiti in modo da evitare difetti in fasi avanzate del progetto, infatti i difetti dovrebbero essere scoperti il più presto possibile, ovvero a livello dei requisiti.
\section{Classificazione dei requisiti}
\begin{itemize}
    \item \textbf{Requisiti utente}: descrizione in linguaggio naturale delle funzionalità che il sistema dovrà fornire e dei vincoli operativi (\underline{sono scritti per (e con) il cliente})
    \item \textbf{Requisiti di sistema}: descrive in modo dettagliato le funzionalità che il sistema dovrà fornire (\underline{sono scritti per gli sviluppatori})
    \item \textbf{Requisiti funzionali}: descrivono ciò che il sistema dovrà fare, non come ma cosa
    \item \textbf{Requisiti non-funzionali}: definiscono vincoli sul sistema e sullo sviluppo del sistema, in generale riguardano la scelta di linguaggi, piattaaforme, strumenti, tecniche d'implementazione, ma anche: prestazioni, questioni etiche, ...
\end{itemize}
Un requisito etico può essere ad esempio che nella realizzazione dell'applicazione verranno utilizzato solo strumenti e servizi 'non proprietari' (es. no Microsoft)
\subsection{Esempio: Bancomat}
In \textcolor{red}{rosso} i requisiti funzionali, in \textcolor{blue}{blu} i requisiti non funzionali
\begin{itemize}
    \item \textcolor{red}{Il sistema deve mettere a disposizione le funzioni di prelievo, saldo e estratto conto}
    \item \textcolor{blue}{Il sistema deve essere disponibile a persone portatori di Handicap, deve garantire un tempo di risposta inferiore al minuto, e deve essere sviluppato su architettura X86 con sistema operativo compatibile con quello della Banca}
    \item \textcolor{red}{Le operazioni di prelievo devono richiedere autenticazione tramite un codice segreto memorizzato sulla carta}
    \item \textcolor{blue}{Il sistema deve essere facilmente espandibile, e adattabile alle future esigenze bancare}
\end{itemize}
\section{Requirements Engineering}
E' il termine usato per descrivere le attività necessarie per raccogliere, documentare e tenere aggiornato l'insieme dei requisiti di un sistema software.
\subsection{Scopo}
Lo scopo primario del RE è la produzione di un documento (il requirement document) che definisca le funzionalità e i servizi offerti dal sistema da realizzare (anche tenerlo aggiornato)
\subsection{Processo iterativo}
\begin{center}
    \includegraphics[width=0.6\textwidth]{Immagini/reiterativo.png}
\end{center}
\begin{itemize}
    \item \textbf{Elicitation}: \begin{itemize}
        \item Ottenere, estrarre, ricavare, tirar fuori i requisiti dal cliente e da altri partecipanti
        \item Il primo passo è identificare gli stakeholders\footnote{Stakeholder: persona veramente interessata allo sviluppo del progetto}
        \item Intervise, osservazioni sul luogo di lavoro, questionari, analisi dei prodotti dei competitors, workshop (brainstorming)
        \item Studio/analisi di leggi e regolamenti, help-desk reports, 'change requests' di prodotti analoghi, 'lessons learned' in progetti simili, ...
    \end{itemize}
    \item \textbf{Analisi dei requisiti}: \begin{itemize}
        \item I bisogni (user needs) degli stakeholders raccolti durante la fase di elicitation sono analizzati e raffinati
        \item Si cerca di capire se i requisiti sono corretti
        \item Si cercano di identificare i "missing requirements"
        \item Si identificano requisiti poco chiari
        \item Si risolvono i requisiti "contradditori o in conflitto"
        \item Viene stabilità la priorità (prioritizzazione): \begin{itemize}
            \item Per sapere cosa "tagliare" se non tutti potranno essere realizzati
            \item Scala numerica
            \item Scala MoSCoW: \begin{itemize}
                \item \textbf{Must have}: requisiti obbligatori
                \item \textbf{Should have}: requisiti importanti ma non indispensabili
                \item \textbf{Could have}: requisiti desiderabili ma non necessari
            \end{itemize} 
        \end{itemize}
    \end{itemize}
    \item \textbf{Definizione e specifica}: \begin{itemize}
        \item Definizione dei requisiti utente: costituisce un contratto fra le parti
        \item Specifica dei requisiti di sistema: costituisce "starting point" per la fase di design
    \end{itemize}
    \item \textbf{Validazione}: \begin{itemize}
        \item Esame della definizione/specifica dei requisiti per valutarne la qualità
        \item Di solito la convalida o validazione si effettua mediante 'formal peer reviewes'
        \item Scrivere dei casi di test a partire dai requisiti
        \item Sviluppare un prototipo
    \end{itemize}
    \item \textbf{Requirements Management}: \begin{itemize}
        \item Approvazione di alcune richieste di cambio dei requisiti
        \item Negoziazione con il cliente
        \item Impact analysis per i cambi richiesti
        \item Tenere allineati i requisiti e il codice (e casi di test)
        \item Tracciare il progresso di un progetto
    \end{itemize}
\end{itemize}
\section{Proprietà dei requisiti}
\begin{itemize}
    \item \textbf{Validità-correttezza}
    \item \textbf{Consistenza}: non ci sono requisiti contradditori
    \item \textbf{Completezza}: tutti gli aspetti che il cliente vuole sono coperti nei requisiti (in teoria)
    \item \textbf{Realismo}: non si chiede l'impossibile
    \item \textbf{Inequivocabilità (Unambiguos)}: ogni requisito dovrebbe avere solo un interpretazione
    \item \textbf{Verificabilità}: i requisiti vanno espressi in modo che siano testabili
    \item \textbf{Tracciabilità}: \begin{itemize}
        \item Ogni funzionalità implementata nel sistema deve poter essere fatta risalire a dei requisiti in modo semplice
        \item Ogni requisito nella requirement specification deve corrispondere ad uno nella requirement definition
    \end{itemize}
\end{itemize}
\section{Template/Schema dei requisiti}
Conviene attenersi a questo Schema
\begin{center}
    \large
    \texttt{<id>} il \texttt{<sistema>} deve \texttt{<funzione>}
\end{center}
Es. \texttt{R1.}Il sistema deve gestire tutti i regitratori di cassa del negozio (non più di 20)
\section{Analista software}
L'analista software o di sistema è la persona che:
\begin{itemize}
    \item si occupa dell'elicitazione dei requisiti
    \item analizza i requisiti
    \item scrive il documento dei requisiti (definizione e/o specifica)
    \item Comunica/spiega i requisiti a sviluppatori e altri stakeholder
\end{itemize}
Alcune competenze che un analista dovrebbe avere:
\begin{itemize}
    \item Arte della negoziazione
    \item Stabilire una strategia (problem solving)
    \item Giusta capacità di imporsi
    \item Ascoltare attentantemente
    \item Dono della sintesi
    \item Padronanza del linguaggio naturale
    \item Buona conoscenza del dominio (ad esempio in ambito medico o automobilistico)
\end{itemize}
\subsection{Consigli per un'intervista}
\begin{enumerate}
    \item Fare molte domande
    \item Ascoltare bene
    \item Mettere in discussione i quantificatori universali: 'tutto, ogni, sempre, ...'
    \item Annotare tutte le risposte
\end{enumerate}
\subsection{Importanza della comunicazione}
\begin{itemize}
    \item Elicitation = Attività molto delicata perchè mette in comunicazione due o più persone di realtà anche molto diverse
    \item Frequenti incomprensioni, che si ripercuotono sulla qualità dei requisiti
\end{itemize}
Occore fare molta attenzione a:
\begin{itemize}
    \item Diversità di significato che si attribuisce ai termini $\rightarrow$ possibile soluzione definizione del glossario: \begin{itemize}
        \item Per la spiegazione dei termini tecnici
        \item Per ridurre l'ambiguità dei termini usati
        \item Per "espandere" gli acronimi
    \end{itemize}
    \item Assunzioni nascoste (Hidden assumptions)
    \item Verbosità (= sovrabbondanza di parole)
    \item Mancanza di chiarezza/precisione
\end{itemize}
\section{Consigli finali}
\begin{itemize}
    \item Riuso di (parte di) requisiti
    \item Utilizzo di un glossario comune tra clienti, utenti e analisti
    \item Utilizzo di un 'buon' template/form
    \item Utilizzo di un software per la geitone/raccolta e analisi dei requisiti
\end{itemize}
\chapter{Definizione dei requisiti basata su use case}
\section{Cosa sono/servono}
\begin{itemize}
    \item Esprimere requisiti funzionali di un sistema
    \item Descrivere dal punto di vista di chi lo usa un sistema, il sistema è visto come una black-box
    \item Totalemnte indipendendti dal mondo OO
    \item Solo testo, formattato in modo standard (template)
    \item Visuale lo Use Case Diagram (UML)
    \item Gli use case esprimono l'interazione tra le entità (attori) che interagiscono con il sistema stesso
\end{itemize}
\section{Differenza tra requisito e use case}
\begin{itemize}
    \item \textbf{Requisito}: descrive una funzionalità dal punto di vista del sistema
    \item \textbf{Caso d'uso}: descrive una modalità di utilizzo del sistema da parte di un utilizzatore (punto di vista dall'utente)
\end{itemize}
La differenza sostanziale è nel modo in cui è presentata l'informazione
\section{Definizione dei requisiti basata su use case}
\begin{itemize}
    \item \textbf{Attore}: rappresenta un ruolo che un entità esterna "recita" interagendo con il sistema, da non confondere un ruolo con la cosa stessa \begin{itemize}
        \item \textbf{Primari}: chi guadagna qualcosa dal sistema (ad esempio un cliente Amazon)
        \item \textbf{Secondari}: chi produce qualcosa (o offre un servizio) per il sistema (ad esempio Paypal)
    \end{itemize}
    \item \textbf{Use case}: quello che gli attori 'possono fare' con il sistema
    \item \textbf{Relazioni}: tra gli attori e gli use case
    \item \textbf{Confini del sistema}: un rettangolo disegnato intorno agli use case per indicare i confini del sistema, quando si vuole costruire un sistema è la prima cosa da fare
\end{itemize}
\section{Scenario}
\customfbox{Uno scenario è una sequenza ordinata di interazioni tra un sistema e gli attori}
Rappresenta una particolare esecuzione di uno use case (istanza), e rappresenta un singolo cammino dello use case, sono usati per il testing. Si possono avere diversi scenari, ma in tutti l'attore può avere lo stesso scopo.
\section{Use Case}
\customfbox{Insieme di scenari che hanno in comune lo scopo finale dell'attore}
\begin{itemize}
    \item Gli use case in genere sono dati come testo strutturato
    \item I passi di uno use case sono testo facile da capire
    \item Viene usato il vocabolario del dominio dell'applicazione
    \item Gli use case sono descrizioni chiare, precide, generali e indipendenti dalle tecnologie
\end{itemize}
\subsection{Descrivere uno use case}
\begin{itemize}
    \item \textbf{Scenario principale}: scenario del mondo perfetto
    \item \textbf{Scenari secondari}: cosa può succedere di sbagliato o differente e come gestirlo
\end{itemize}
\subsection{Template}
\begin{itemize}
    \item \textbf{Nome dello use case}: è il goal dello use case \texttt{"breve frase verbale attiva"} in UpperCamelCase
    \item \textbf{Identificatore}: di solito numerico progressivo
    \item \textbf{Breve descrizione}: un paragrafo che fissa l'obbiettivo dello use case
    \item \textbf{Attori primari}: l'attore/gli attori primari dello use case
    \item \textbf{Attori secondari}: gli attori che "servono" per svolgere lo use case
    \item \textbf{Precondizioni}: vincoli sullo stato corrente del sistema
    \item \textbf{Scenario principale}: i passi che costituiscono lo use case
    \item \textbf{Postcondizioni}: condizioni che devono essere vere quando lo use case termina con successo l'esecuzione dello scenario principale
    \item \textbf{Scenari alternativi}: un elenco di alternative allo scenario principale
\end{itemize}
Uno scenario è costituito da un elenco di passi che devono essere concisi, numerati e ordinati temporalmente: \texttt{<numero> Il <Sistema/Attore> <qualche azione>}. Si ha una deviazione tutte le volte che 'ci si allontana' dallo scenario principale: \begin{itemize}
    \item \textbf{Semplici}: usare parola chiave \texttt{se} nella sequenza principale
    \item \textbf{Complesse}: scrivere sequenze degli eventi alternative che rappresentano errori o casi particolari che non ritornano sullo scenario principale
\end{itemize}
Si possono usare ripetizioni all'interno di una sequenza: \texttt{per} e \texttt{fintantochè}.\\
E' possibile che una sequenza venga attivata in qualunque momento della sequenza principale.
\section{Gerarchia attori}
\begin{center}
    \includegraphics[width=0.2\textwidth]{Immagini/attori.png}
\end{center}
Come per le classi di Java, l'attore specializzato eredita le relazioni dell'attore generale
\section{Relazioni tra use case}
\begin{itemize}
    \item \textbf{Inclusione \texttt{<<include>>}}: \begin{itemize}
        \item Assomiglia al concetto di procedura/funzione
        \item Lo use case "principale" esegue i passi fino al punto di inclusione e passa il controllo allo use case incluso, alla fine il controllo ritorna allo use case principale
        \item Lo use case principale senza use case incluso risulta incompleto
    \end{itemize}
    \item \textbf{Estensione \texttt{<<extend>>}}: per estendere il comportamento di uno use case con un comportamento aggiuntivo (opzionale) rispetto allo use case base
    \item \textbf{Generalizzazione/specializzazione}: gli use case specializzati (figli) rappresentano delle varianti più specifiche dello use case generalizzato (genitore) da cui ereditano, i 'figli' possono \begin{itemize}
        \item Ereditare i passi del genitore
        \item Aggiungere nuovi passi
        \item Ridefinire (modificare) i pasi ereditati
    \end{itemize}
\end{itemize}
\chapter{Design architetturale}
\section{Introduzione}
\customfbox{Trasforma un problem in una soluzione (come)}
Il design definisce la struttura della soluzione invece l'implementazione la realizza, rendendola usabile.
\begin{itemize}
    \item \textbf{Architectural design (high-level)}: mappa i requisiti su architettura SW e componenti/sottosistemi
    \item \textbf{Component design (low-level)}: fissa dettagli dei componenti, specificando maggiormente la soluzione
\end{itemize}
Scelte tecnologiche:
\begin{itemize}
    \item \textbf{platform-independent design}: come pro ha il riuso
    \item \textbf{platform-specific design}: come pro aiuta i programmatori, per specifico si intende ad esempio nominare già le strutture dati specifiche per un linguaggio.
\end{itemize}
\subsection{Livelli di ri-uso}
\begin{itemize}
    \item \textbf{Clonazione}: si riutilizza interamente design/codice, con piccoli aggiustamenti
    \item \textbf{Design pattern}: buona soluzione a problema ricorrente
    \item \textbf{Stili architetturali}: architettura generica che suggerisce come decomporre il sistema
    \item \textbf{Software Frameworks}: insieme di classi e interfacce cooperanti che realizzano un design per uno specifico dominio applicativo o tipologia di app
\end{itemize}
\section{Design architetturale}
Processo di design per identificare:
\begin{itemize}
    \item le macro componenti di un sistema
    \item come avviene il controllo e la comunicazione tra componenti
\end{itemize}
Produce una descrizione dell'architettura software.
\section{Componenti}
\customfbox{Un modulo è un'unità del sistema che offre servizi ad altre unità, ma che non può essere considerato un sistema a se stante}
Un sottosistema è un sistema di per sè: può essere eseguito ed utilizzato anche "da solo". Di solito i sottosistemi sono composti da moduli ed hanno interfacce ben definite, che sono utilizzate per la comunicazione con altri sottosistemi.
\section{Diagramma a blocchi}
Un architettura software è normalmente espressa mediante un diagramma a blocchi che presenta un "overview" della struttura del sistema. I blocchi sono i componenti, i connettori rappresentano le "relazioni" tra i componenti.
\begin{center}
    \includegraphics[width=0.5\textwidth]{Immagini/diagrammablocchi.png}
\end{center}
\section{Architettura SW}
\subsection{Proprietà del sistema}
\begin{itemize}
    \item \textbf{Performance}: tempi di risposta rapidi
    \item \textbf{Security}: difficile da "manomettere", dati sensibili protetti
    \item \textbf{Safety}: non creare "disastri"
    \item \textbf{Availability}: 24//7/365
    \item \textbf{Maintainability}: semplice da mantenere/evolvere
\end{itemize} 
\subsection{Vantaggi}
\begin{itemize}
    \item Guida lo sviluppo ed aiuta nella comprensione del sistema
    \item Documenta il sistema
    \item Aiuta a ragionare sull'evoluzione del sistema
    \item Supporta decisioni manageriali
    \item Facilita l'analisi di alcune proprietà
    \item Permette il riuso (Large-scale)
\end{itemize}
\subsection{Stili architetturali}
L'architettura di un sistema può conformarsi a uno stile architetturale
\begin{itemize}
    \item \textbf{Modello generico}: con caratteristiche specifiche che può essere istanziato/personalizzato
    \item \textbf{Layered}
    \item \textbf{Repository}
    \item \textbf{Client/server}
    \item \textbf{P2P}
    \item \textbf{Broadcast model}
    \item \textbf{Service Oriented Architecture}
    \item \textbf{Microservice}
\end{itemize}
Uno stile \textbf{strutturale} fornisce solo informazioni strutturali, uno \textbf{di controllo} anche informazioni (o solo) di controllo.\\
\customfbox{Conoscere gli stili architetturali può semplificare il problema di definire l'architettura software}
La maggioranze dei grandi sistemi sono \underline{eterogenei} e non seguono un singolo stile architetturale
\subsubsection{Elementi}
\begin{itemize}
    \item \textbf{Componenti}
    \item \textbf{Connettori}
\end{itemize}
\subsection{Layered}
\begin{itemize}
    \item Organizza il sistema in un insieme di livelli ognuno dei quali fornisce un insieme di servizi
    \item Un livello usa solo i servizi del livello inferiore
\end{itemize}
\begin{center}
    \includegraphics[width=0.4\textwidth]{Immagini/layered.png}
\end{center}
\subsection{Repository}
I dati condivisi sono mantenuti in un database centrale (repository o blackboard) a cui hanno accesso tutti i sotto-sistemi
\begin{center}
    \includegraphics[width=0.5\textwidth]{Immagini/repository.png}
\end{center}
\subsection{Client/server}
\begin{itemize}
    \item Modello di sistema distribuito che mostra come i dati e la computazione possono essere distribuiti su: \begin{itemize}
        \item Insieme di server che forniscono servizi specifici
        \item Insieme di client che utilizzato tali servizi
    \end{itemize}
    \item Esiste una rete che permette ai client di accedere ai server
\end{itemize}
\subsubsection{Two-Tier}
Tre strati/componenti software:
\begin{itemize}
    \item Interfaccia utente (presentation logic)
    \item Gestione dei processi e logica (business o appl. logic)
    \item Gestione del DB (data logic)
\end{itemize}
Distribuiti in due livelli ($n$ client + $m$ server)
\begin{itemize}
    \item Client
    \item Server
\end{itemize}
\begin{center}
    \includegraphics[width=0.8\textwidth]{Immagini/thinclientfatclient.png}
\end{center}
\subsubsection{Three-Tier}
\begin{itemize}
    \item Sul client resta solo l'interfaccia utente
    \item La logica del sistema risiede sull'Application server e gestisce multi-utenti
    \item Gli strati di logica e gestione DB sono distribuiti su più DB server
\end{itemize}
\subsection{Pipe and Filter}
\begin{itemize}
    \item I filtri effettuano trasformazioni che elaborano i loro input per produrre output
    \item Le pipe sono connettori che trasmettono i dati tra filtro e filtro
\end{itemize}
Ad esempio \texttt{ls -l | grep "Aug} dove l'output di \texttt{ls -l} viene passato a \texttt{grep "Aug"} grazie alla pipe
\subsection{Architetture eterogenee}
Ci sono due modi di combinare gli stili ottenendo così un architettura eterogenea:
\begin{itemize}
    \item Modo gerarchico
    \item Permettendo che una componente sia un mix di architetture
\end{itemize}
\subsection{Microservices}
\customfbox{Avere servizi separati e quindi potenzialmente più piccoli e facili da gestire (sviluppare, testare, deployare), anche dislocati su server diversi}
\subsubsection{Perchè?}
Se la app cresce:
\begin{itemize}
    \item La complessità aumenta
    \item Difficile trovare e risolvere bug
    \item Difficile effettuare  modifiche
    \item Tempi estesi per il deploy
    \item Complesso lavorare in parallelo (team)
\end{itemize}
\begin{center}
    \includegraphics[width=0.8\textwidth]{Immagini/monolithvsmicroservice.png}
\end{center}
Ogni microservizio può essere scritto in un linguaggio di programmazione diverso ed avere diversi DBMS.
\subsubsection{Comunicazione}
\begin{itemize}
    \item \textbf{API Gateway}: espone un'interfaccia verso i client
    \item \textbf{REST}: le applicazioni basate su REST utilizzano le richieste HTTP per tutte e quattro le operazioni di \texttt{CRUD} (Create, Read, Update, Delete)
\end{itemize}
\subsubsection{Problemi}
\begin{itemize}
    \item Stabilire la dimensione dei micro servizi
    \item Sviluppo del meccanismo di comunicazione tra i servizi
    \item Esposizione ai disservizi di rete
    \item Gestione dello schema partizionato dei DB
    \item Difficoltà di testing
    \item Maggior consumo di risorse e memoria
\end{itemize}
\chapter{Design delle componenti}
\section{Fasi}
\begin{center}
    \includegraphics[width=0.7\textwidth]{Immagini/processocomponentifasi.png}
\end{center}
\section{Design by contract}
E' un metodo di design per il software che ha come obiettivo quello  di migliorarne la qualità e prescrive che il progettista debba definire specifiche precise delle interfacce dei classi/componenti software, basandosi sulla metafora di un contratto legale (il "contratto", viene creato per ogni componente del sistema \underline{prima che sia codificato}). L'idea centrale è che una componente software ha degli obblighi nei confronti delle altre componenti.
\subsection{Elementi di un contratto}
\begin{itemize}
    \item \textbf{Pre-condizione}: espressione a valori booleani rappresentante le aspettative sullo 'stato del mondo' prima che venga eseguita un'operazione
    \item \textbf{Post-condizione}: espressione a valori booleani riguardante lo 'stato del mondo' dopo l'esecuzione di un'operazione
    \item \textbf{Invariante di classe}: condizione che ogni oggetto della classe deve soddisfare quando è 'in equilibrio'
\end{itemize}
\textbf{Le precondizioni sono utili?} a prima vista potrebbe risultare inutile in quanto si possono aggiungere controlli all'interno del codice però chi è responsabile di questi controlli? Senza una dichiarazione esplicita  potremmo avere \begin{enumerate}
    \item \textbf{Troppi pochi controlli}
    \item \textbf{Troppi controlli}
\end{enumerate}
\subsection{Vantaggi}
\begin{itemize}
    \item Codifica: guida per lo sviluppatore durante la fase di codifica
    \item Migliorano la qualità del software: definisce quale componente è responsabile ad effettuare i controlli. Aiuta a scrivere operazioni semplici  che soddisfino un contratto ben definito
    \item Documentazione: \texttt{Pre}, \texttt{Post} e \texttt{Invarianti} documentano in  modo preciso cosa fa una componente/classe
    \item Testing: guida alla generazione di casi di test "black-box"
    \item Debugging: permette di trovare il "colpevole" di un malfunzionamento: \begin{itemize}
        \item Le eccezioni si sollevano quando il contratto è violato
    \end{itemize}
\end{itemize}
\section{Progettazione degli algoritmi}
E' l'attività più vicina alla codifica (spesso viene lasciata in parte o totalmente agli sviluppatori) e, di solito, si seguono i seguenti passi:
\begin{enumerate}
    \item Si analizza la descrizione di design della classe "target"
    \item Se esistono una o più operazioni che necessitano di un algoritmo, se  è possibile selezionare un algoritmo noto si seleziona altrimenti occorre definire un algoritmo e si sceglie una notazione e si progetta utilizzando la nozione di "stepwise refinement"
    \item Si usano i metodi formali per provare la correttezza dell'algoritmo proposto
\end{enumerate}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{Immagini/stepwiserefinement.png}
    \caption{Stepwise Refinement}
\end{figure}
\subsection{Notazioni}
Esistono diverse notazioni utilizzate per rappresentare un algoritmo:
\begin{itemize}
    \item \textbf{Visuali}: Activity Diagram di UML, Flowchart, Box Diagram, Structured Chart, Decision Table, \ldots
    \item \textbf{Testuali}:  Program Design Language (PDL) o pseudocodice
\end{itemize}
\subsubsection{PDL}
Il \textbf{Program Design Language} (PDL) o pseudocodice è un linguaggio semplificato che usa il vocabolario di un linguaggio naturale e la sintassi di un linguaggio di programmazione.
\section{Principi di progettazione}
\customfbox{I principi di progettazione guidano verso il raggiungimento degli obiettivi di qualità per il progetto}
Porta a produrre software: manutenibile, comprensibile, semplice da testare, riusabile, riparabile e portatile \ldots\\
Si possono applicare per tutti i sistemi non solo Object Oriented!
\subsection{Principi}
\subsubsection{Astrazione}
Permette di concentrarsi su un problema ad un determinato livello di astrazione, senza perdersi in dettagli irrilevanti. Nasconde informazioni che a un determinato livello non servono.\\
Forme di astrazione:
\begin{itemize}
    \item \textbf{Funzionale}:: definizione di una funzionalità indipendentemente dall'algoritmo che la implementa
    \item \textbf{di Dati}: definizione di un tipo di dato in base alle operazioni che su di esso possono essere fatte, senza definirne una struttura concreta
    \item \textbf{di Controllo}: definizione di un meccanismo di controllo senza indicarne i dettagli interni
\end{itemize}
\subsubsection{Decomposizione}
Cercare di risolvere un problema in una volta sola è in genere più difficile che risolverlo per parti.
\customfbox{\textbf{Legenda:} \begin{itemize}
    \item $P$ problema
    \item $C(P)$ complessità di $P$
    \item $E(P)$ effort (sforzo) per la risoluzione (software) di $P$
\end{itemize}}
Dati due problemi $P_{1}$ e $P_{2}$
\begin{itemize}
    \item Se $C(P_{1})>C(P_{2})$ allora vale $E(P_{1})>E(P_{2})$
    \item $C(P_{1}+P_{2})>C(P_{1})+C(P_{2})$ vale empiricamente
    \item $E(P_{1}+P_{2})>E(P_{1})+E(P_{2})$
\end{itemize}
L'ultima disequazione porterebbe a una conclusione sbagliata che se noi dividessimo il problema e quindi il software infinite volte l'effort di sviluppo diventerebbe nullo. In realtà entrano in gioco altre variabili:
\begin{center}
    \includegraphics[width=.7\textwidth]{Immagini/decomposizionegraph.png}
\end{center}
Quindi dal grafico sappiamo che non si deve dividere troppo nè troppo poco.
\subsubsection{Modularità}
\customfbox{\textbf{Modulo}: è un'entità SW, identificata da un nome che può fornire servizi software; contiene istruzioni, strutture dati, controllo; può essere incluso in un altro modulo; può usare un altro modulo o parte di esso con la relazione 'dipende da'}
E' una conseguenza del principio di decomposizione, l'idea è quella di tenere separati gli aspetti "unrelated" di un software (\textbf{Separation of concerns}). Una valida linea guida è tenere separati il SW di generazione dati dal SW necessario alla loro presentazione e permette di cambiare la rappresentazione sullo schermo senza dover modificare il sistema di calcolo. La struttura di un'applicazione software, è spesso caratterizzata da tre livelli:
\begin{itemize}
    \item \textbf{Presentazione}: insieme dei moduli che gestiscono l'interazione con l'utente
    \item \textbf{Logica Applicativa}: insieme dei moduli che realizzano la logica applicativa, implementano le funzionalità richieste e gestiscono il flusso dei dati
    \item \textbf{Dati e Risorse}: insieme dei moduli che gestiscono i dati che rappresentano le informazioni utilizzate
\end{itemize}
Per modularizzare sostanzialmente bisogna fare in modo che ogni modulo esegua un singolo compito e minimizzare il numero e la complessità delle interconnessioni fra moduli. Dei moduli coesi e poco accoppiati sono\begin{itemize}
    \item facili da comprendere
    \item riusabili
    \item semplici da modificare
    \item semplici da testare
\end{itemize}
Bisogna evitare i moduli "monster" e per far ciò bisogna seguire i criteri per una buona modularizzazione: moduli piccoli, separation of concerns, alta coesione e basso accoppiamento e usare delle metriche o delle view per vedere se i criteri sono stati applicati.\\
Un modulo \textbf{coeso} svolge un \underline{unico compito}, in altre parole coesione è quando un modulo deve esprimere una sola astrazione, esistono diverse tipologie di coesione ma di solito si intende quella \textbf{funzionale}: tutti gli elementi del modulo contribuiscono ad un singolo ben definito task.\\
\customfbox{Ogni modulo non deve dipendere da troppi altri moduli, nè dipendervi in modo troppo forte}
Il coupling misura (informalmente) il grado di dipendenza di un modulo dagli altri e come prima non bisogna collegarli troppo e troppo poco.
\begin{itemize}
    \item Accoppiamento buono: chiamata di routine/metodo/funzione di altro modulo, uso di tipo di dato definito in altro modulo, inclusione o importazione di un package o di una libreria
    \item Accoppiamento cattivo: content coupling, un modulo modifica il valore di una variabile in un altro modulo
\end{itemize}
L'accoppiamento cattivo va evitato perchè complica enormemente la compresione e la modifica, in un sistema OO si riduce incapsulando tutti i campi di una classe dichiarandoli privati e fornendo i metodi di get e set. Nei linguaggi 'Legacy' le cose sono più complicate\ldots
\begin{itemize}
    \item \textbf{Fan-in}: numero di archi entranti in un modulo
    \item \textbf{Fan-out}: numero degli archi uscenti da un modulo
\end{itemize}
Un alto numero di Fan-in indica un buon riuso, un alto numero di Fan-out indica eccessiva dipendenza e che il modulo "fa troppo" (va decomposto).\\
\textbf{Generalità}: è la proprietà di design che "migliora" il riuso di un modulo in altri progetti (in futuro), si cerca di rendere un modulo il più generale possibile in modo da poterlo usare in più contesti. Questo principio è controverso perchè 'peggiora' un altro principio quello della 'semplicità' (KISS).
\subsection{Principio KISS}
Il design dovrebbe essere il più semplice possibile.
\begin{itemize}
    \item Keep It Simple, Stupid
    \item Keep It Short and Simple
\end{itemize}
\subsection{Sto seguendo i principi?}
Esistono delle metriche del SW che ci permettono di misurare l'aderenza a principi che abbiamo visto:
\begin{itemize}
    \item Metrica SW, ovvero la misura quantitativa del grado di possesso di uno specifico attributoda parte di un sistema, un componente, o un processo (es. LCOM (Lack of Cohesion))
    \item Esistono dei tool che forniscono  metriche e viste
\end{itemize}
\textbf{Esempio di metrica LCOM}
\begin{center}
    LCOM = numero di intersezioni vuote - numero di intersezioni non vuote
\end{center}
\includegraphics[width=0.3\textwidth]{Immagini/esempioLCOM.png}
Le intersezioni saranno $I_{1}=\{a,b,c\},I_{2}=\{b,c\},I_{3}=\{x,y\}$ quindi si avrà che $I_{1}\cap I_{2} \neq \emptyset $ mentre $I_{1}\cap I_{3} =I_{2}\cap I_{3} = \emptyset$ quindi avremo che $LCOM = 2-1 = 1$ e visto che è $>0$ classe $C$ non è coesa.
\chapter{UML - Introduzione}
\section{Cos'è}
L'UML è una famiglia di notazioni grafiche utili a supportare la descrizione e il progetto dei sistemi software. E' stato proposto come standard dall'OMG (Object Management Group) che ha come obiettivo di creare standard nel contesto IT.\\
E' unificato perchè in pratica è una collezione di varie notazioni preesistenti (Rumbaugh, Booch, Jacbson, Harel), integrate e rese Object Oriented.\\
L'UML \textbf{non} è:
\begin{itemize}
    \item Un metodo/processo di sviluppo $\rightarrow$ e' un linguaggio/notazione
    \item Un linguaggio di programmazione $\rightarrow$ è un linguaggio di modellazione
    \item Legato a UP (Unified Process) $\rightarrow$ è indipendente dal processo
\end{itemize}
L'UML può essere usato in diversi modi: 
\begin{itemize}
    \item \textbf{Abbozzo (sketch)}: per aiutare la comunicazione e la discussione
    \item \textbf{Progetto dettagliato (blueprint)}: per fornire un modello completo/dettagliato da implementare
    \item \textbf{Linguaggio di programmazione}: per fornire un "modello eseguibile"
\end{itemize}
\section{Prospettive}
\begin{itemize}
    \item \textbf{Prospettiva software}: gli elementi rappresentati sono elementi di un sistema software, serve per descrivere il design di un sistema software e per documentare un sistema software
    \item \textbf{Prospettiva concettuale}: gli elementi rappresentati sono concetti del dominio e serve per modellare il dominio del business e i processi
\end{itemize}
\section{Modello di dominio (del business)}
E' una rappresentazione visuale di classi concettuali o di oggetti del mondo reale di un dominio ed è un glossario visuale delle astrazioni significative del dominio.\\
E' utile per:
\begin{itemize}
    \item Chiarire i concetti di dominio nel quale il sistema software che dobbiamo progettare andrà inserito
    \item Ispirare nomi di alcune classi e attributi software nel design
    \item La progettazione del sistema
\end{itemize}
\section{Un po' di storia}
\begin{center}
    \begin{tikzpicture}
        % draw a horizontal line
        \draw (0,0) -- (18.5,0);
        
        % draw vertical lines
        \foreach \x in {1,3.5,5.5,7.5,9.5,11.5,13.5,15.5,17.5}
        \draw (\x cm,3pt) -- (\x cm,-3pt);
        
        % draw nodes to add events
        \draw (1,0) node[above=3pt] {Anni '80} node[below=3pt] {
        \begin{varwidth}{2cm}
            \begin{center}
                \footnotesize
                Linguaggi ad oggetti iniziano a prendere piede
            \end{center}
        \end{varwidth}
        };
        \draw (3.5,0) node[above=3pt] {1980-1995} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    "babele" di linguaggi di modellazione
                \end{center}
            \end{varwidth}
        };
        \draw (5.5,0) node[above=3pt] {1994} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    Rumbaugh si unisce a Booch alla Rational Software (azienda)
                \end{center}
            \end{varwidth}
        };
        \draw (7.5,0) node[above=3pt] {1995} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    Booch e Rumbaugh presentano OOPSLA Unified Method v 0.8 \\
                    Viene dato l'annuncio che Ratinal ha comprato Objctory dove lavora Jacobson
                \end{center}
            \end{varwidth}
        };
        \draw (9.5,0) node[above=3pt] {1996} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    OMG entra in campo sollecitata dai venditori di strumenti software terrorizzati dalla possibilità che Rational creasse un standard de-facto
                \end{center}
            \end{varwidth}
        };
        \draw (11.5,0) node[above=3pt] {1997} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    call for proposal da parte di OMG. \\
                    "Tre amigos" presentano UML 1.0
                \end{center}
            \end{varwidth}
        };
        \draw (13.5,0) node[above=3pt] {11/1997} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    Nasce UML 1.1 (standard OMG)
                \end{center}
            \end{varwidth}
        };
        \draw (15.5,0) node[above=3pt] {03/2005} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    UML 2.0 diventa la versione ufficiale
                \end{center}
            \end{varwidth}
        };
        \draw (17.5,0) node[above=3pt] {Adesso} node[below=3pt] {
            \begin{varwidth}{2cm}
                \begin{center}
                    \footnotesize
                    UML 2.5.1
                \end{center}
            \end{varwidth}
        };
    \end{tikzpicture}
\end{center}
\section{Perchè}
Studiare UML è utile perchè è uno standard, è usato/richiesto dall'industria (almeno a livello di abbozzo) ed è indispenabile per le figure di Analista e Progettista (architetto) software.\\
Non lo studieremo in modo approfondito perchè, ad esempio, l'approccio blueprint è  poco usato nell'industria.
\section{Notazione e meta-modello}
UML definisce una famiglia di notazioni e un meta-modello.
\customfbox{Notazione = sintassi grafica del linguaggio \\ Meta-modello = definisce i concetti stessi del linguaggio}
\textbf{Esempio di meta-modello}: UML di una classe (generica) Java
\begin{center}
    \includegraphics[width=.8\textwidth]{Immagini/UMLmetamodello.png}
\end{center}
In UML un sistema viene descritto utilizzando diverse viste e diversi diagrammi
\customfbox{Vista = particolare aspetto di un sistema SW dal punti di vista di uno specifico ruolo}
Un diagramma descrive/presenta una view/subview, chiameremo \textbf{Modello} un insieme di diagrammi che descrivono aspetti diversi dello stesso sistema SW. In un modello bisogna fare attenzione a non avere viste possibilmente sovrapposte (problema di consistenza) e incomplete (problema di completezza).\\
Il diagramma UML non è abbastanza e per questo esistono due soluzioni:
\begin{itemize}
    \item Si cerca o si produce un "estensione" di UML (profilo UML)
    \item Si usano diagrammi non UML
\end{itemize}
Facendo ciò si perde uno dei  vantaggi di UML: la standardizzazione.
\subsection{Profilo}
Come anticipato, UML si può estendere tramite il concetto di profilo per avere la possibilità di specificare particolari domini applicativi o tipologie di applicazioni.\\
Un profilo è costituito principalmente da:
\begin{itemize}
    \item \textbf{Stereotipi}: elementi aggiuntivi ottenuti modificando quelli esistenti
    \item \textbf{Vincoli aggiuntivi}
    \item \textbf{Informazioni semantiche aggiuntive} relative agli elementi aggiuntivi
\end{itemize}
\customfbox{Non si può guardare un diagramama UML e dire esattamente cosa farà il codice corrispondente}
Esiste un UML "legale"? La risposta è si e no: quello definito dalla specifica del  linguaggio (documento OMG) è quello legale ma UML è molto complesso e si presta a multiple interpretazioni, così le persone lo usano adottando convenzioni particolari (per semplificare) e quindi si perde la standardizzazione. Di solito si aggiunge nei diagrammi "\textbf{non-normativo}".
\section{Come usare UML}
\begin{enumerate}
    \item Capire il punti di vista dell''autore per capire i diagrammi
    \item Meglio dei buoni diagrammi "illegali" che altri formalmente corretti ma "scarsi"
    \item UML è molto complesso da prestarsi a multiple interpretazioni: usate un sottoinsieme e solo i diagrammi che ritenete utili (e che avete compreso bene)
    \item La completezza è nemica della chiarezza
    \item Qualsiasi informazione in UML può essere sempre soppressa
\end{enumerate}
\chapter{UML - Class Diagram}
\section{Introduzione}
Definisce:
\begin{itemize}
    \item Le classi
    \item Le loro feature \begin{itemize}
        \item Attributi
        \item Operazioni
    \end{itemize}
    \item Le relazioni tra classi \begin{itemize}
        \item Associazioni
        \item Aggregazione/Composizione
        \item Specializzazione/Generalizzazione
        \item Dipendenze
    \end{itemize}
\end{itemize}
Ovvero la parte statica di quello che intendiamo modellare.
\section{Prospettive}
Il significato di un class diagram e dei suoi elementi dipende dalla prospettiva:
\begin{itemize}
    \item Prospettiva concettuale: descriviamo gli elementi del "pezzo di mondo" che ci interessa modellare, la classe UML è un concetto proprio del dominio e un'operazione UML è un'azione/responsabilità
    \item Prospettiva software: descriviamo il design di un software, ovvero i modulo software che costituiranno l'implementazione vera e propria del sistema, la classe UML è una classe in un linguaggio OO e un'operazione UML è implementata da un metodo
\end{itemize}
\section{Classe}
Il concetto di classe è lo stesso dell'OO, incapsula caratteristiche comuni ad un gruppo di progetti, una classe genera oggeto con \texttt{create()} e un oggetto è un istanza di una classe. Gli attributi determinano lo stato degli oggetti mentre le operazioni descrivono il comportamento. Gli oggetti connessi tra loro possono collaborare per compiere task più complessi mediante scambio di messaggi.
\subsection{Rappresentazione}
Una classe in UML è semplicemente rappresentata da un rettangolo con il nome della classe all'interno, possiamo aggiungere gli attributi e le operazioni.
\begin{center}
    \includegraphics[width=.3\textwidth]{Immagini/UMLClass.png}
\end{center}
Se una classe è \texttt{abstract} viene indicata con il nome in corsivo.\\
Si ha una dipendenza tra due classi se la modifica di una classe può avere effetto sull'altra, si rappresenta con una freccia tratteggiata.
\subsection{Attributi}
\begin{center}
    \texttt{visibilità nome: tipo [molteplicità] = default \{proprietà\}}
\end{center}
\begin{itemize}
    \item \textbf{Visibilità}: \begin{itemize}
        \item \texttt{+}: pubblico
        \item \texttt{-}: privato
        \item \texttt{\#}: protetto
        \item \texttt{\~}: package
    \end{itemize}
    \item Il nome dell'attributo è l'unica parte obbligatoria
    \item Il tipo dell'attributo può essere: \begin{itemize}
        \item Primitivo
        \item Il nome di una classe definita nello stesso modello
    \end{itemize}
    \item Default rappresenta il valore di default dell'attributo di un oggetto appena creato
    \item Proprietà aggiuntive (es. \texttt{readOnly})
\end{itemize}
Le regole di visibilità tra i vari linguaggi e UML sono spesso differenti.\\
Gli attributi possono essere \texttt{static} e, come per il linguaggio Java, gli oggetti di una stessa classe condividono lo stesso valore per un attributo. In UML si indica sottolineando il nome dell'attributo.
\subsection{Molteplicità}
La molteplicità indica il quntitativo degli attributi, alcuni valori possibili sono:
\begin{itemize}
    \item 1 (uno e uno solo). E' il valore di default
    \item 0..1 (al più uno)
    \item * (un numero imprecisato, eventualmente nessuno)
    \item 1..* (almeno uno)
    \item n..m con $m\geq 1$
\end{itemize}
Gli elementi di un attributo con molteplicità $>1$ sono considerati come un insieme, se essi sono dotati anche di ordine si aggiunge la proprietà \texttt{\{ordered\}}
\subsection{Operazioni}
\begin{center}
    \texttt{visibilità nome (lista parametri) : tipo-ritornato {proprietà}}
\end{center}
\begin{itemize}
    \item Visibilità e nome stesse regole degli attributi
    \item Lista parametri contiene nome e tipo dei parametri, secondo la forma \texttt{direzione nome : tipo = default}
    \item Direzione: input (in), output (out) o entrambi (inout). Il valore di default è in.
    \item nome, tipo e valore di default sono analoghi a quelli degli attributi
    \item Tipo-ritornato è il tipo del valore di ritorno
\end{itemize}
\customfbox{Le operazioni get/set di solito non si indicano perchè è scontato che esistono}
In UML esistono due tipi di operazioni:
\begin{itemize}
    \item \textbf{Query} che ottengono un valore da un oggetto senza side efficiente
    \item \textbf{Modificatori} che modificano gli attributi (lo stato) dell'oggetto su cui sono chiamate
\end{itemize}
Un operazione può essere \texttt{static} e, come per il linguaggio Java, le operazioni non operano solo su una particolare istanza della classe ma sulla classe stessa. in UML si indica sottolineando il nome dell'operazione.
\customfbox{Un operazione viene invocata su un oggetto e corrisponde alla dichiarazione di una procedura/funzione, un metodo è il corpo di tale procedura/funzione, è l'implementazione di un operazione}
Se un'operazione è \texttt{abstract} viene indicata con il nome in corsivo.
\section{Datatype}
In UML esiste il concetto di datatype, per sua natura un oggetto ha un identità mentre un datatype no: le istanze sono valori non oggetti. Si rappresentano come classi con lo stereotipo \texttt{<<datatype>>}
\section{Associazioni}
\customfbox{Un'associazione rappresenta una relazione tra classi}
Il \texttt{>} indica in che direzione deve essere letta l'associazione, in alternativa si può indicare il ruolo di uno dei due estremi dell'associazione. In un diagramma delle classi non è consigliato aggiungere nomi delle associazioni e ruoli. \\
Il verso di navigazione indica in quale direzione è possibile reperire le informazioni ($\rightarrow$).
\subsection{Molteplicità}
La molteplicità delle associazioni indica il numero di link tra gli oggetti delle classi e, come in SQL, si mettono sulla freccia ai due estremi.
\subsection{Attributi}
Di solito si usano attributi per tipi primitivi e datatype o associazioni se tipati da classi.\\
Un associazione riflessiva è quando una classe ha un'associazione con se stessa.
\subsection{Implementazione (Java)}
\begin{itemize}
    \item Associazione molteplicità 1: \texttt{attributo}
    \item Associazione molteplicità 0..*: \texttt{HashSet}
    \item Associazione molteplicità \{ordered\} 0..*: \texttt{LinkedList} o \texttt{ArrayList}
\end{itemize}
Esistono anche le associazioni bidirezionali ma non possono essere implementate con un singolo attributo. Con le associazioni bidirezionali 1..1 c'è un problema di sincronizzazione.
\section{Note}
E' un commento in un linguaggio di programmazione, si usa anche per specificare il "behaviour" di un'operazione
\section{Aggregazione}
Rappresenta la relazione "tutto-parti", è una relazione di tipo "è composto da" e si rappresenta con un rombo vuoto.
\section{Composizione}
\textbf{Forma forte} di aggregazione: esprime la relazione "ha-un"/"è composto di", le proprietà sono:
\begin{itemize}
    \item Se il composto/intero viene distrutto, anche le sue parti saranno distrutte
    \item Una parte può appartenere ad un solo oggetto intero alla volta
\end{itemize}
\section{Generalizzazione ed ereditarietà}
\begin{itemize}
    \item \textbf{Generalizzazione = relazione "è un"}, ogni istanza di una classe è anche istanza della superclasse
    \item \textbf{Ereditarietà}: meccanismo attraverso il quale elementi specializzati incorporano la struttura ed il comportamento di elementi più generali. Nella classe erede è possibile aggiungere nuovi attributi e operazioni e ridefinire le operazioni (overriding)
\end{itemize}
\chapter{UML - Sequence Diagram}
\section{Diagrammi di interazione}
Descrivono la collaborazione di un gruppo di oggetti (ovvero i messaggi), i messaggi possono essere 
\begin{itemize}
    \item \textbf{Sincroni}: il mittente si pone in attesa del risultato
    \item \textbf{Asincroni}: il mittente continua l'esecuzione
\end{itemize}
\section{Notazione}
\begin{itemize}
    \item \textbf{Messaggio trovato (input)}: si rappresenta come freccia continua che, nella coda, ha un pallino nero
    \item \textbf{Messaggio}: come per il messaggio trovato tranne che non c'è pallino
    \item \textbf{Controllo del partecipante}: si rappresenta come un rettangolo "verticale" sotto il partecipante, indica quando il partecipante ha il controllo del flusso
\end{itemize}
\section{Sintassi dei messaggi}
\begin{itemize}
    \item \textbf{Self}: chiamata di un metodo appartenente alla classe stessa (è una freccia che parte e arriva alla stessa classe)
    \item \textbf{Creazione}: creazione di un oggetto (si rappresenta con una freccia tratteggiata per indicare la dipendenza da un altro oggetto)
    \item \textbf{Distruzione}: distruzione di un oggetto (si indica con un messaggio che finisce con una X)
\end{itemize}
\section{Frame}
\subsection{Cicli e condizioni}
Cicli e condizioni (la logica di controllo) possono essere espressi mediante i frame di interazione, un frame è un rettangolo che racchiude un gruppo di messaggi.
\begin{center}
    \includegraphics[width=.4\textwidth]{Immagini/loopUML.png}
    \includegraphics[width=.4\textwidth]{Immagini/ifUML.png}
\end{center}
Ovviamente i frame possono essere annidati.
\subsection{Ref}
\texttt{Ref} sta per \textbf{reference} è usato per semplificare i sequence diagram. Simile al concetto di "procedura" in un linguaggio di programmazione.
\subsection{Par}
Utile per esprimere l'interazione di oggetti complessi che possono eseguire diverse azioni/operazioni in parallelo.\\
I diagrammi di sequenza:
\begin{center}
    \begin{tabular}{| p{8cm} | p{8cm} |}
        \hline
        \textbf{Pro} & \textbf{Contro} \\
        \hline
        Ottimo mezzo per visualizzare l'interazione tra oggetti & Non buono per spiegare i dettagli degli algoritmi, come i cicli e i comportamenti condizionali \\
        \hline
    \end{tabular}
\end{center}
M. Fowler suggerisce di limitare l'uso dei frame di interazione perchè sono molto pesanti.
\section{Sequence Diagram di Sistema (SSD)}
Un diagramma di sequenza di sistema illustra gli eventi di input ed output del sistema relativi ad uno o più scenari di un caso d'uso.\\
Serve a stabilire con precisione quali sono gli eventi di input e di output del sistema e a rappresentare un punto di partenza per la progettazione delle classi e le loro operazioni e l'analisi dei contratti delle operazioni.
\section{Comunication Diagram}
E' una variante del sequence diagram che mette in evidenza la comunicazione tra oggetti.
\chapter{UML - State Machine \& Activity Diagram}
\section{State Machine}
\customfbox{Le state machine vengono usate per descrivere il comportamento di una Entità come variazione del suo stato interno quando è sottoposta a sollecitazioni dal mondo esterno (eventi)}
Più semplicemente le state machine descrivono cosa fa un entità quando riceve un input. Un entità può comportarsi in modo diverso a seconda del suo stato interno.\\
Una state machine è associata a una classe.
\subsection{Stato}
Rappresenta una situazione durante la quale delle condizioni vengono soddisfatte e delle attività possono essere eseguite.\\
Gli stati di una macchina a stati UML sono qualcosa di più astratto: ad ognuno di essi corrisponde un diverso comportamento del sistema al verificarsi degli eventi.
\subsection{Rappresentazione grafica}
Graficamente le state machine UML sono dei grafi dove i nodi sono gli stati e gli archi sono le transizioni. In questi grafi lo stato iniziale è rappresentato da un pallino nero che si collega a uno stato iniziale, sugli archi c'è scritto il nome dell'evento e se vicino al nome ci sono delle parentesi quadre dentro c'è la guardia.
\subsubsection{Semantica}
\begin{itemize}
    \item Una macchina a stati è sempre associata ad un entità e ne descrive il suo comportamento
    \item La macchina a stati riceve eventi che vengono salvati su una coda ed estratti uno alla volta
    \item \textbf{Run-to-completion}: un evento viene estratto solo dopo che il precedente è stato processato
    \item Se ci sono più transizioni eseguibili in un dato momento solo una viene eseguita in modo non determistico
    \item Un disco nero marca il nodo d'inizio dell'esecuzione, è unico per ogni diagramma di stato
    \item Un disco nero bordato marca il nodo finale e possono comparire in qualunque numero all'interno di un diagramma
\end{itemize}
\begin{center}
    \includegraphics[width=.7\textwidth]{Immagini/UMLStateMachine.png}
\end{center}
\subsubsection{Transizioni}
Ogni transizione, oltre allo stato origine e destinazione \textbf{può} specificare:
\begin{itemize}
    \item \textbf{Evento}: un 'trigger' che attiva il passaggio di stato, qualcosa che l'entità subisce
    \item \textbf{Guardia}: una condizione che, se vera, permette il passaggio di stato. Può essere espressa in linguaggio naturale, pseudo-linguaggio, linguaggio di programmazione o in OCL
    \item \textbf{Attività}: una o più azioni che sono compiute dall'entità prima di cambiare stato, possono essere espresse in modo informale (linguaggio naturale) o sotto forma di pseudolinguaggio
\end{itemize}
Una transizione avviene come risposta ad un evento, e al momento della transizione l'entità esegue l'attività specificata.
\subsection{Altri tipi di eventi in UML}
\begin{itemize}
    \item \texttt{when} (evento di cambiamento): si verifica quando una condizione passa da falsa a vera
    \item \texttt{After, At} (evento temporale): si verifica dopo un certo tempo o ad una data/ora "precisa"
\end{itemize}
\subsubsection{Attività interne}
Uno stato  può reagire ad eventi e compiere attività anche senza una transizione ad uno stato diverso. Queste attività sono:
\begin{itemize}
    \item \texttt{entry}: eseguita quando l'oggetto entra nello stato
    \item \texttt{exit}: eseguita quando l'oggetto esce dallo stato
    \item \texttt{do-activity}: eseguita mentre l'oggetto è nello stato, può durare per un intervallo di tempo ed essere interrotta da altri eventi
\end{itemize}
Una \texttt{self-transition} attiva sempre le entry ed exit, le attività interne no.\\
Un attività interna di solito si scrive:
\begin{center}
    \texttt{evento/azione eseguita}
\end{center}
\subsection{Stati compositi (superstati)}
Uno stato composito permette di suddividere la complessità del modello, si può  usare un icona per rappresentare uno stato composito il cui comportamento interno non è mostrato:
\begin{center}
    \includegraphics[width=.7\textwidth]{Immagini/UMLCompositeState.png}
\end{center}
\section{Activity Diagram}
\customfbox{Descrivono come viene svolta un'attività relativa ad una qualsiasi entità, quale è il flusso di azioni che devono  accadere}
\subsection{Attività}
Un'attività è costituita da un flusso di azioni che ne sono i mattoni.
\subsubsection{Costrutti}
\begin{center}
    \includegraphics[width=.7\textwidth]{Immagini/UMLActivityNodes.png}
\end{center}
I flussi vengono rappresentati con frecce.
\begin{itemize}
    \item \textbf{Nodi azione}: specificano unità di comportamento, può essere espressa in modo informale, può invocare un'altra attività, può invocare un'operazione di una classe e, volendo, si può scrivere anche un frammento di codice all'interno del simbolo di azione. A volte si può trovare il simbolo \includegraphics[height=2\fontcharht\font`\B]{Immagini/rake.png} (rake) che indica che un azione è specificata a parte da un altro diagramma di attività.
    \item \textbf{Nodi oggetto}: specificano oggetti usati come input e output di azioni
    \item \textbf{Nodi di controllo}: specificano il flusso delle attività
\end{itemize}
Un nodo azione viene eseguito quando sono presenti i token su tutti gli archi in entrata, un token può essere rappresentato come un cerchio colorato.
\subsection{Nodi inizio e fine}
L'utilizzo dei nodi inizio e fine attività è uguale a quello dei nodi inizio e fine di stato: il nodo inizio (cerchio nero) è unico e il nodo fine (cerchio nero  bordato) può essere ripetuto più volte.\\
Esiste anche il nodo  finale \textbf{di flusso} che è rappresentato da un cerchhio con una x al centro e causa la terminazione del flusso non dell'attività però al raggiungimento di un nodo finale di attività causa comunque la terminazione di tutti i flussi.
\subsection{Nodi decisione e fusione}
Si possono rappresentare entrambi come rombi, i nodi decisione hanno un input e vari output mentre il nodo fusione ha vari input e un output.
\subsection{Nodi fork e join}
I nodi fork e join si possono rappresentare come rettangoli neri, il nodo fork divide un'esecuzione in più flussi concorrenti, il nodo join sincronizza e riunisce i flussi.
\chapter{UML - Component, Package \& Deployment Diagram}
\section{Component Diagram}
\customfbox{Una scatola nera il cui comportamento esterno è completamente definito dalle sue interfacce, sono rimpiazzabili e componibili}
\subsection{Componente}
I componenti sono entità logiche che sono realizzate da artfatti (che sono invece entità fisiche).\\
\textbf{Esempio}:
\begin{center}
    \textcolor{blue}{Sottosistema} realizzato tramite un \textbf{insieme di classi}
\end{center}
Dove il sottosistema è l'entità logica e l'insieme di classi l'entità fisica.\\
\textbf{Perchè si usano le componenti per descrivere l'architettura di un sistema SW?}\\
    Le classi sono componenti di grana troppo fine per dare una buona panoramica del sistema.\\
Un componente è mostrato come rettangolo con:
\begin{itemize}
    \item Parola chiave \texttt{<<component>>} oppure l'icona \includegraphics[height=2\fontcharht\font`\B]{Immagini/componentUML.png}
    \item Nome
\end{itemize}
Esistono parole chiave più specifiche come:
\begin{itemize}
    \item \texttt{<<Web service>>}, \texttt{<<Microservice>>}, \texttt{<<Subsystem>>}, \dots
\end{itemize}
Se ne possono sempre aggiungere
\subsection{Interfacce}
\begin{minipage}
    {.4\textwidth}
    Sono composte da:
    \begin{itemize}
        \item Lollipop (fornite) \includegraphics[height=2\fontcharht\font`\B]{Immagini/lollipopInterface.png}
        \item Socket (richieste) \includegraphics[height=2\fontcharht\font`\B]{Immagini/socketInterface.png}
    \end{itemize}
\end{minipage}
\begin{minipage}
    {.5\textwidth}
    \begin{center}
        \includegraphics[width=\textwidth]{Immagini/interface.png}
    \end{center}
\end{minipage}
\subsection{Dipendenza}
I componenti possono essere connessi anche con la relazione di dipendenza (una freccia tratteggiata con scritto \texttt{<<use>>}), spesso usato quando sono utilizzate più interfacce ma non si vuole specificare quali sono.
\begin{center}
    \includegraphics[width=.6\textwidth]{Immagini/dependence.png}
\end{center}
Se i un componente c'è scritto \texttt{\{global\}} vuol dire che è usata da tutti i componenti.
\begin{center}
    \includegraphics[width=.3\textwidth]{Immagini/global.png}
\end{center}
\section{Deployment Diagram}
\customfbox{E' una vista molto implementativa che mostra la relazione tra hardware e software in un sistema SW. E' presente un forte link tra component e deployment diagram.}
\subsection{Nodi e connessioni}
\begin{itemize}
    \item \textbf{Nodi}: rappresenta un tipo di risorsa computazionale: \begin{itemize}
        \item \textbf{Periferica fisica} (\texttt{<<device>>})
        \item \textbf{Ambiente software di esecuzione}
    \end{itemize}
\end{itemize}
Una connessione tra nodi rappresenta un canale di comunicazione attraverso cui possono passare delle informazioni (es. TCP/IP).
\subsection{Artefatti}
Sono entità concrete del mondo reale (file di codice sorgente, script, \dots),  possono essere dislocati sui nodi. Esiste anche la relazione di dipendenza tra artefatti.
\subsection{Manifest}
La relazione \textbf{manaifest} indica che gli artefatti sono rappresentazioni/manifestazioni fisiche dei componenti.
\begin{center}
    \includegraphics[width=.4\textwidth]{Immagini/manifest.png}
\end{center}
\section{Package Diagram}
\customfbox{Descrivono i package e le dipendenze}
\subsection{Package}
Un package (in UML) è un costrutto che permette di prendere un numero arbitrario di elementi UML e raggrupparli insieme, può contenere sia elementi che sotto-package.\\
\textbf{Come suddividere le classi in package?}\\
Seguendo i principi di buona progettazione:
\begin{itemize}
    \item High cohesion and low coupling
    \item Common Reuse Principle: le classi in un package dovrebbero essere sempre riusate assieme
    \item Acyclic Dependency Principle: no cicli
    \item \dots
\end{itemize}
\subsubsection{Namespace}
Ogni package definisce un namespace, lo scopo dei namespace è quello di evitare confusione ed equivoci nel caso siano necessarie molte entità con nomi simili in un progetto SW. Per indicare la classe a cui mi sto riferendo occorre usare un nome completamente qualificato, ad esempio:
\begin{center}
    \texttt{System::Data}\\
    \includegraphics[width=.2\textwidth]{Immagini/package.png}
\end{center}
\subsection{Visibilità}
Gli elementi contenuti in un package possono avere una visibilità che indica se gli elemento sono visibili o meno ai clienti del package:
\begin{itemize}
    \item \texttt{+}: pubblico
    \item \texttt{-}: privato
\end{itemize}
\begin{center}
    \includegraphics[width=.2\textwidth]{Immagini/packagevisibility.png}
\end{center}
\newpage
\subsection{Dipendenze}
\begin{center}
    \includegraphics[width=.5\textwidth]{Immagini/packagedipendence.png}
\end{center}
In questo caso \texttt{Fish} dipende da \texttt{Water}: vuol dire che nel package \texttt{Fish} esiste \textbf{almeno} una classe che dipende da una classe che è nel package \texttt{Water}. La classe in \texttt{Water} deve essere visibile.
\subsection{In pratica}
\begin{itemize}
    \item Progettare l'applicazione cercando di seguire il più possibile i principi di buona progettazione
    \item Generare il diagramma dei package a partire dal  codice stesso usando tool specifici di reverse engineering
    \item Identificare cicli, package poco coesi e package con tante dipendenze entranti per ristrutturare il sistema
\end{itemize}
\chapter{Software Design Patterns}
E' una soluzione elegante (con un nome) di uno specifico problema di design/programmazione OO che costituisce un unità di riuso. L'idea di design pattern deriva da Kent Beck. Attualmente molti cataloghi di pattern sono in genere relativi a un particolare dominio applicativo o a una particolare tipologia di applicazioni.\\
I design pattern aiutano ad applicare i principi di buona progettazione OO, possono essere applicati sia durante la modellazione che la codifica e facilitano la comunicazione tra sviluppatori.
\section{Altre unità di riuso}
\begin{itemize}
    \item Librerie
    \item Componenti riusabili (COTS)
    \item Framework: è un insieme di classi e interfacce cooperanti che realizzano un design riusabile e customizzabile per uno specifico dominio applicativo o tipologia di app, la differenza con la libreria è che lo sviluppatore di un'applicazione scrive le classi (in particolare le operazioni) che vengono chiamate dal framework mentre con una libreria lo sviluppatore chiama le operazioni delle classi di una libreria
    \item Product line
    \item Modelli
\end{itemize}
I design pattern, rispetto ai framework, sono più astratti, più piccoli, di solito sono meno specializzati: non relativi a un dominio applicativo specifico o tipologia di app.
\section{GRASP}
I pattern elementari GRASP sono pattern per l'assegnazione di responsabilità nel software, costituiscono il fondamento per la progettazione di sistemi OO.
\subsection{Pattern Controller}
\textbf{Problema}: quale è il primo oggetto oltre lo strato di UI che riceve e coordina un operazione di sistema (i messaggi)?\\
\textbf{Soluzione}: assegna la responsabilità ad una classe che rappresenta una delle seguenti scelte:
\begin{itemize}
    \item Sistema piccolo: classe che rappresenta il sistema complessivo
    \item Sistema grande: classe relativa al caso d'uso all'interno del quale si verifica l'evento, solitamente chiamata \texttt{Handler} o \texttt{Controller}
\end{itemize}
\section{Design pattern classici}
\begin{itemize}
    \item Creazionali: creazione degli oggetti
    \item Strutturali: composizione di classi
    \item Comportamentali: come classi (oggetti) interagiscono tra di loro e si distribuiscono le responsabilità
\end{itemize}
Un template è piuttosto preciso, noi vedremo la versione semplificata:
\begin{itemize}
    \item Nome (una/due parole)
    \item Problema: descrive quando applicare il pattern e può contenere anche delle precondizioni per poterlo applicare
    \item Soluzione
    \item Conseguenze: pro/contro della sua applicazione
\end{itemize}
\subsection{I pattern creazionali}
\customfbox{Sono pattern che hanno a che fare con la creazione di istanze}
Di solito per risolvere questo problema ci si affida al pattern GRASP Creator, tuttavia esistono casi in cui non conviene applicare il pattern Creator.
\subsubsection{Factory}
Quando si vuole separare la logica di creazione dalla logica applicativa pura si ricorre al concetto di Factory in cui viene definito un oggetto specifico Factory con l'unico scopo di creare oggetti.\\
\textbf{Abstract Factory} fornisce una soluzione per creare famiglie di prodotti in modo che non ci sia necessità da parte dei client di specificare le classi concrete dei prodotti all'interno del proprio codice. E' utile in quanto separa le responsabilità, si produce un design (quindi un codice) migliore.\\
Conseguenze:
\begin{center}
    \begin{tabular}{| p{5cm} | p{12cm} |}
        \hline
        \textbf{Pro} & \textbf{Contro} \\
        \hline
        Isola le classi concrete & Non è facile aggiungere nuovi prodotti:può richiedere cambiamenti all'interfaccia dell'Abstract Factory e alle sue sottoclassi, richiede l'aggiunta di una nuova classe ConcreteFactory e di nuovi AbstractProducts e Products \\    
        \hline
        Rende il cambio della famiglia dei prodotti facile & \\
        \hline
        Favorisce  la consistenza tra i vari prodotti di una famiglia & \\
        \hline
    \end{tabular}
\end{center}
\section{Adapter}
Converte l'interfaccia di una classe in un'altra interfaccia che il cliente di aspetta, permette a delle classi di lavorare assieme anche se non potrebbero visto che hanno interfacce incompatibili.
\begin{center}
    \includegraphics[width=0.5\textwidth]{Immagini/adapter.png}
\end{center}
\textbf{Problema}: usare una classe esistente, la cui interfaccia non è quella che il cliente si aspetta, si vuole creare una classe che collabora con classi non correlate o che non si conoscono ancora.
\section{Façade}
\textbf{Problema}: rendere più semplice l'accesso a sottosistemi che espongono interfacce complesse, fornire un'unica interfaccia per un insieme di funzionalità "sparse" su più interfacce/classi.\\
Conseguenze:
\begin{itemize}
    \item Promuove un accoppiamento debole fra cliente e sottosistema
    \item Nascone al cliente le componenti (complesse) del sottosistema
    \item Il cliente può comunque, se necessario, usare direttamente le classi del sottosistema
\end{itemize}
La differenza con l'adapter è che quest'ultimo la converte un'interfaccia mentre il façade la semplifica.
\section{Template Method}
Definisce lo scheletro (template) di un algoritmo in un metodo posponendo la definizione di alcuni passi a delle sottoclassi.\\
\textbf{Problema}: implementare la parte invariante di un algoritmo una sola volta, e lasciare alle sottoclassi l'implementazione delle parti che possono variare.\\
Le operazioni che costituiscono la parte variabile sono chiamate \textbf{primitive}. Normalmente sono le sottoclassi a chiamare i metodi delle superclassi, con questo pattern è il metodo del template a chiamare i metodi specifici ridefiniti nelle sottoclassi.\\
Conseguenze:
\begin{center}
    \begin{tabular}{| p{5cm} | p{12cm} |}
        \hline
        \textbf{Pro} & \textbf{Contro} \\
        Tecnica fondamentale per il riuso del codice & Importante chiarire bene quali operazioni devono essere ridefinite nelle sottoclassi \\
        \hline
        Realizza inversione del flusso di controllo & \\
        \hline
        Permette di avere anche più sottoclassi concrete & \\
        \hline
    \end{tabular}
\end{center}
\section{Observer}
Gli osservatori sono oggetti che catturano e informano gli altri osservatori di un cambiamento di stato di un oggetto osservato.\\
Gli osservatori si registrano presso l'oggetto osservato, quando l'oggetto osservato cambia stato (\texttt{cambiato(): boolean}), notifica tutti gli osservatori (\texttt{notify()}) e, quando notificato, ogni osservatore decide cosa fare (niente o \texttt{getState()}).\\
Definisce una dipendenza allentata (larga) uno a molti tra oggetti, in modo che quando un oggetto cambia stato, tutti gli oggetti che dipendono da lui sono avvertiti.\\
\textbf{Problema}:
\begin{itemize}
    \item Associare più "viste" differenti ad un  modello (dati)
    \item Implementare il broadcast
    \item Il cambiamento di un oggetto richiede il cambiamento di altri oggetti
    \item Notificare oggetti senza fare assunzioni a priori su quali siano questi oggetti
\end{itemize}
\subsection{Interfacce}
L'oggetto osservato deve fornire un'interfaccia standard per la registrazione, deve anche poter notificare  con \texttt{notify()} che chiama tutti gli \texttt{update()} dei registrati  e gli osservatori devono fornire un'interfaccia standard per la notifica \texttt{update()} che a sua volta chiamerà \texttt{getState()} dell'osservato.
\begin{center}
    \includegraphics[width=0.5\textwidth]{Immagini/observerinterface.png}
\end{center}
\subsection{Conseguenze}
\begin{center}
    \begin{tabular}{| c | c |}
        \hline
        \textbf{Pro} & \textbf{Contro} \\
        \hline
        Supporto per la comunicazione broadcast & Modifiche inaspettate \\
        \hline
        Collegamento tra osservato e osservatore modificabile & \\
        \hline
    \end{tabular}
\end{center}
\section{Model View Controller (MVC)}
E' un pattern architetturale (quindi avremo una granularità maggiore rispetto ai design pattern) che divide un'applicazione con GUI in tre tipologie di componenti:
\begin{itemize}
    \item Un modello: contiene i dati e le funzionalità di base
    \item Una o più viste: mostrano informazioni agli utenti
    \item Uno o più controller: gestiscono le richieste degli utenti
\end{itemize}
Un'interfaccia utente è formata da una (o più) vista e un (o più) controller.
\section{State Pattern}
\textbf{Scopo}: permettere a un oggetto di cambiare il suo comportamento al variare del suo stato interno. Questo permette di implementare le state machine UML.\\
\textbf{Come?} Si estrae la rappresentazione dello stato in classi esterne organizzate in una gerarchia, si sfrutta il polimorfismo per variare il comportamento.\\
Però è difficile da comprendere e mantenere (praticamente bisogna aggiungere un \texttt{if} per ogni metodo evento e ovviamente avere tanti \texttt{if} non è buono), un'alternativa è usare lo State Pattern: si usa una gerarchia di classi per rappresentare gli stati della macchina.
\chapter{Code Refactoring}
\customfbox{
    Un cambiamento eseguito alla struttura interna di un software per renderla più facile da capire è più economica da modificare senza cambiare il suo comportamento osservabile. \\
    \textbf{Martin Fowler}
}
Refactoring: è una riorganizzazione, ristrutturazione del codice (di solito OO) senza modificarne il comportamento.
\section{Legacy System}
Sistemi per i quali l'aattività di manutenzione è diventata prevalente su ogni altra.\\
\textbf{Problemi}:
\begin{itemize}
    \item Sono stati implementati diversi anni fa
    \item La loro tecnologia è diventata obsoleta
    \item Sono stati mantenuti per un lungo periodo
    \item La loro struttura si è deteriorata e non è facile comprendere il codice
    \item La loro documentazione (se esiste) non è allineata
    \item Gli autori originali non sono più disponibili
    \item \textbf{Contengono 'regole di business' che non sono documentate altrove}
    \item \textbf{Non possono essere sostituiti facilmente}
    \item \textbf{Rappresentano un grosso investimento per l'azienda}
\end{itemize}
\subsection{Convivere con un Legacy System}
\textbf{Obiettivo}: migliorare la qualità del SW e contenere i costi.\\
\textbf{Approcci principali}:
\begin{itemize}
    \item Redocumentation: processo che mira a produrre una vista del codice 'alternativa' utile per la comprensione
    \item Restructuring/Refactoring: trasformazione di codice 'mal-strutturato' in codice 'ben-strutturato'
    \item Reverse Engineering: creazione del design e delle specifiche a partire dal codice, esiste anche la definizione forte che prevede (oltre alla rappresentazione grafica) l'inferire i requisiti/specifiche
    \item Re-engineering: reverse engineering + modifica di specifiche e design + forward engineering (creazione di un nuovo sistema basato su specifiche e design rivisitati)
\end{itemize}
\section{Perchè?}
\begin{center}
    \includegraphics[width=.7\textwidth]{Immagini/reasonwhyrefactoring.png}
\end{center}
Ma anche:
\begin{itemize}
    \item Semplificare la fase di testing
    \item Limitare design decay/erosion
\end{itemize}
\section{Quando?}
\customfbox{Applicare il refactoring il più spesso possibile durante lo sviluppo}
\begin{itemize}
    \item Si vuole aggiungere una nuova funzionalità al sistema
    \item Quando si corregge un bug
    \item Quando viene rilevato un \textbf{code smell}
\end{itemize}
\subsection{Code Smell}
Indicatore che qualcosa nel codice non va bene, potrebbe essere solo un qualcosa di \textbf{stile}, oppure che riduce la \textbf{comprensione} del codice oppure nascosto c'è un problema più grave. Spesso i tool che calcolano le metriche del software ci indicano quali sono i code smell presenti.\\
Esempi:
\begin{itemize}
    \item 'Troppo' codice come ad esempio metodi lunghi
    \item 'Non abbastanza' codice come ad esempio le \texttt{Data class} ovvero classi con solo campi e i metodi getter/setter
    \item Al di fuori del codice come ad esempio commenti inutili
\end{itemize}
\subsection{Clone Software}
E' codice duplicato e questo può causare 'bug propagation' e problemi di manutenzione.
\section{Il ritmo}
\begin{enumerate}
    \item Trova/identifica code smell
    \item Modifica (\underline{piccola}) del codice seguendo una procedura definita in modo preciso dal catalogo dei refactorings
    \item Compila
    \item Esegui i test
\end{enumerate}
Ripeti per ogni code smell trovato nel codice.
\subsection{Catalogo dei Refactorings}
Molti refactoring sono "piccoli e semplici" (low-level refactoring) però sono i building-blocks per i refactoring complessi.
\begin{center}
    \includegraphics[width=\textwidth]{Immagini/refactoringscatalog.png}
\end{center}
\section{Come?}
\begin{itemize}
    \item Eseguire manualmente i refactoring
    \item Utilizzare un tool di supporto
\end{itemize}
Chiaramente usare un tool è la soluzione più comoda, tuttavia spesso i tool forniscono solo refactoring semplici. In entrambi i casi è meglio sempre controllare ri-eseguendo i casi di test.
\subsection{Tools}
Gli IDE di solito hanno incorporato alcuni refactoring semplici, esistono anche tool o plug-in specifici che suggeriscono refactoring più complessi.
\subsubsection{Move method}
Si applica quando le classi hanno 'troppo behaviour' oppure quando abbiamo classi che collaborano troppo o sono troppo accoppiate. E' un refactoring facile, il difficile però è trovare i metodi 'giusti' da spostare, dei buoni candidati sono metodi che sembrano riferirsi più ad altre classi che alla classe a cui appartengono.
\subsubsection{Replace Temp with Query}
\textbf{Contesto}: le variabili locali possono essere viste solo nel contesto di un metodo così incoraggiano ad avere metodi lunghi.\\
\textbf{Soluzione}: rimpiazzando le variabili locali con un metodo query, ogni metodo della classe può ottenere quell'informazione.
\subsubsection{Replace Paramerer with Method}
\textbf{Contesto}: metodi che hanno molti parametri sono difficili da capire e la lista dei parametri dovrebbe essere ridotta il più possibile.\\
\textbf{Soluzione}: se un metodo può ottenere un valore che gli è stato passato allora dovrebbe fare quel calcolo per ottenerlo direttamente al suo interno.
\subsubsection{Extract Class}
\textbf{Contesto}: esiste una classe che fa troppo (God class o Blob class)\\
\textbf{Soluzione}: si crea una nuova classe e si sposta in questa alcuni attributi e operazioni, se non si vuole modificare l'interfaccia lasciamo le operazioni "che delegano" alla nuova classe tutto il lavoro.
\subsubsection{Replace Inheritance with Delegation}
Una sottoclasse usa solo parte di una superclasse e non vuole ereditare il resto
\subsubsection{Replace Conditional with Polymorphism}
Esiste una condizione che sceglie differenti comportamenti a seconda del tipo/valore di una variabile
\subsubsection{Separate Domain from Presentation}
Abbiamo  una GUI che contiene anche la Business Logic, non c'è "separation of concerns"
\chapter{Software Testing}
\customfbox{E' una procedura sistematica che prevede l'esecuzione di un sistema software (SUT) con l'intento di trovare \textbf{failure}}
\begin{itemize}
    \item \textbf{Errore}: commesso da uno sviluppatore, può essere di battitura o concettuale
    \item \textbf{Fault}: l'errore presente all'interno del programma
    \item \textbf{Failure}: manifestazione di una fault durante l'esecuzione
\end{itemize}
\section{Debugging}
\customfbox{Il processo usato per trovare un bug/fault a partire dal failure e rimuoverlo}
Due fasi:
\begin{itemize}
    \item Fault localization/location
    \item Fault removal
\end{itemize}
\section{Testing}
E' un processo esaustivo e "non realizzabile" nei casi reali perchè occorre selezionare "pochi e buoni" (buoni = con alta probabilità di trovare un fault) input nel dominio di tutti gli input possibili.
Gli input vengono selezionati secondo l'approccio che si decide di seguire:
\begin{itemize}
    \item \textbf{Black box}: non è basato su una conoscenza del SUT e della sua struttura, di solito gli input sono generati a partire dai requisiti/specifiche. Viene chiamato anche \textbf{functional testing}
    \item \textbf{White box}: è basato su una conoscenza esplicita del SUT e della sua struttura, viene chiamato anche \textbf{structural testing}
\end{itemize}
\section{Testcase \& Testsuite}
\begin{itemize}
    \item \textbf{Testcase} (caso di test): un insieme di input, precondizioni e risultati attesi sviluppati per un particolare obiettivo come eseguire un particolare percorso del programma o per verificare la conformità di un requisito specifico
    \item \textbf{Testsuite}: una collezione di testcase
\end{itemize}
\section{Tipologie di testing}
\begin{itemize}
    \item \textbf{Testing di unità} (Implementazione): l'unità viene testata dallo sviluppatore isolandola il più possibile dal resto, di solito approccio white-box
    \item \textbf{Testing di integrazione} (Implementazione/Integrazione): i moduli/componenti sono "testati insieme", viene testato come comunicano i moduli/componenti e quali info vengono scambiate. Le interfacce tra moduli di solito sono fonti di errori
    \item \textbf{Testing di sistema} (Testing di Sistema): il "testing group" verifica che il software soddisfa i requisiti e anche i bisogni dall'utente (acceptance testing), di solito black-box
    \item \textbf{Testing di regressione} (Manutenzione): tutte le volte che si effettua una modifica in un applicazione c'è il rischio di side effect in zone del codice che apparentemente non sembrerebbero impattate dalla modifica, lo scopo del test di regressione è verificare che non ci siano state delle regressioni (side effect/peggioramenti)
\end{itemize}
\section{Testing manuale VS Testing automatizzato}
Nel testing automatizzato i tester implementano dei test script (porzioni di codice in grado di interagire con il SUT, per esempio inserendo input) che sono eseguiti da un framework che dopo la loro esecuzione riporta il risultato (pass/fail).
\subsection{JUnit}
E' un framework di testing per programmi Java che ci permette di realizzare il test automatizzato. Sviluppato da: Erich Gamma e Kent Beck.
\section{White-box Testing}
\subsection{Code coverage}
Di solito la qualità di una testsuite $T$ si valuta misurando la copertura di $T$ rispetto al programma $P$. Ad esempio il numero di linee di codice eseguite durante la fase di testing sul totale di linee di codice. La coverage può essere basata sul codice sorgente o su modelli generati a partire dal codice (es. grafo di flusso di controllo, state machines, data flow graph, \dots) o requisiti e specifiche.
\subsubsection{Control Flow Graph (CFG)}
Rappresenta mediante un diagramma di flusso tutti i possibili cammini che possono essere attraversati durante l'esecuzione di $P$. \textbf{Esistono diverse rappresentazione (e numerazioni) equivalenti di CFG}.
\begin{itemize}
    \item Statement (node) coverage: coprire tutti i nodi del CFG
    \item Branch coverage: coprire tutti i branch anche chiamato decision coverage, è la copertura minima richiesta da "IEEE unit test standard"
    \item Multiple Condition Coverage (MCC): copre tutte le combinazioni possibili delle condizioni nei nodi decisionali
    \item All Paths Coverage: copertura di tutti i cammini del CFG in pratica è impossibile (ci sono i loop)
\end{itemize}
\subsubsection{In pratica}
\begin{enumerate}
    \item Si sceglie un criterio: \begin{itemize}
        \item Seguendo gli standard o le prescrizioni aziendali (di solito branch coverage)
        \item Considerando che, in generale: \begin{itemize}
            \item più è la power (livello di difficoltà di implementazione) più è complesso trovare i casi di test
            \item più è la power più aumenta la dimensione della testsuite
            \item più è la power più aumentano i costi e i tempi di esecuzione
            \item più è la power più è probabile che la testsuite riveli dei fault
        \end{itemize}
    \end{itemize}
    \item Si sceglie una copertura
    \item Si crea una testsuite seguendo il criterio scelto con tanti casi di test al fine di raggiungere la copertura voluta...
\end{enumerate}
\subsubsection{Statement Coverage}
\textbf{Criterio}: tutti gli statement devono essere coperti durante l'esecuzione della testsuite.\\
E' il criterio più debole di copertura.\\
\textbf{Procedura}: \begin{enumerate}
    \item Selezionare alcuni path che coprono tutti gli statement
    \item Scegliere gli input in modo da percorrere i path selezionati
\end{enumerate}
\subsubsection{Branch Coverage}
\textbf{Criterio}: tutti i branch devono essere coperti durante l'esecuzione della testsuite.\\
I branch \texttt{true} e \texttt{false} degli if statement, ogni \texttt{case} in uno statement \texttt{switch} e ogni loop.\\
\textbf{Procedura}: \begin{enumerate}
    \item Selezionare alcuni path che coprono tutti i branch
    \item Scegliere gli input in modo da percorrere i path selezionati
\end{enumerate}
\subsubsection{Multiple Condition Coverage}
\textbf{Criterio}: ogni condizione atomica deve essere coperta (occorrono degli input che la rendono true e false), in una condizione composta ogni combinazione delle condizioni atomiche deve essere coperta durante l'esecuzione dei casi di test.
\subsubsection{All Paths Coverage}
\textbf{Criterio}: tutti i cammini del CFG devono essere coperti
\customfbox{Non applicabile!}
\textbf{Problemi}
\begin{itemize}
    \item Non usabile in pratica quando ci sono dei loop (troppi cammini), di solito si semplifica trattando i loop in modo binario: viene eseguito o no
    \item Alcuni cammini potrebbero essere \textbf{infeasible}, potrebbe essere che non esiste una combinazione di input che ci permetta di scegliere un particolare path, questa cosa è vera anche per gli altri criteri ma è molto più complicato
\end{itemize}
\subsection{Limiti}
Spesso il numero di casi di test prodotti è molto grande, per questo motivo è spesso usato solo per Unit testing per piccole porzioni del sistema (Testing in the small) e non è in grado di rivelare i fallimenti dovuti a "missing feature errors" (possono essere scoperti solo considerando i requisiti/specifiche)
\section{Black-box Testing}
Il black box testing può essere usato con qualsiasi tipo di sistema indipendentemente dalla tecnologia/piattaforma/linguaggio usato, può essere usato per Unit, Integration e System testing (usato soprattutto per System testing). Gli sviluppatori possono scrivere casi di test non appena i requisiti del sistema sono disponibili cioè prima che il codice venga scritto.
\subsection{Equivalence Partitioning}
\begin{enumerate}
    \item Partizionamento dei dati di input
    \item L'input domain è suddiviso in classi tale che il risultato risulta essere una partizione
    \item Le classi sono create assumendo che il SUT esibirà lo stesso behaviour su tutti gli elementi della classe
    \item A questo punto si sceglie un input per ogni classe e si testa il programma (l'input scelto è rappresentativo della classe)
\end{enumerate}
Di solito il primo passo è quello di dividere l'input domain in due classi:
\begin{itemize}
    \item Input legali
    \item Input illegali
\end{itemize}
A loro volta queste classi possono ancora essere suddivise.
\section{Boundary Value Analysis (BVA)}
Si scelgono i casi di test in prossimità della frontiera (confini) delle varie classi di equivalenza (si applica dopo Equivalence Partitioning). Si basa sul seguente assunto: è più probabile commettere errori vicino alla frontiera che non all'interno delle classi.
\begin{enumerate}
    \item Partizionare l'input domain (Equivalence Partitioning)
    \item Identificare i confini per ogni partizione
    \item Selezionare gli input in modo tale da comprendere i confini (e i punti vicini)
\end{enumerate}
\end{document}